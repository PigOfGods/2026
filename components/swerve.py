"""Swerve drivetrain using CTRE Phoenix 6 swerve API."""

import math
from typing import Optional

from choreo import SwerveSample
from magicbot import feedback
from phoenix6.hardware import CANcoder, TalonFX
from phoenix6.swerve import SwerveDrivetrain
from phoenix6.swerve.requests import (
    FieldCentric,
    Idle,
    SwerveDriveBrake,
    SwerveRequest,
)
from wpilib import Field2d, RobotBase, RobotController, SmartDashboard
from wpimath.controller import PIDController
from wpimath.geometry import Pose2d, Rotation2d
from wpimath.kinematics import ChassisSpeeds
from wpimath.units import meters_per_second, radians_per_second

from generated.tuner_constants import TunerConstants

# Simulation period in seconds (20ms = 0.020s for standard robot loop)
SIM_LOOP_PERIOD = 0.020


class Drivetrain:
    """Swerve drivetrain wrapper using CTRE Phoenix 6 SwerveDrivetrain.

    This class wraps the Phoenix 6 SwerveDrivetrain to integrate with MagicBot's
    component system. The Phoenix 6 API handles all the low-level control.

    Configuration is loaded from generated/tuner_constants.py which is designed
    to be regenerated by Phoenix Tuner X's Swerve Project Generator.
    """

    # PID gains for trajectory following - tune these for your robot!
    # These provide feedback to correct position error during trajectory following
    TRAJECTORY_X_KP = 10.0
    TRAJECTORY_Y_KP = 10.0
    TRAJECTORY_HEADING_KP = 7.5

    def __init__(self) -> None:
        """Initialize the swerve drivetrain with all modules."""
        # Create the Phoenix 6 SwerveDrivetrain using TunerConstants
        self._drivetrain = SwerveDrivetrain(
            TalonFX,
            TalonFX,
            CANcoder,
            TunerConstants.drivetrain_constants,
            [
                TunerConstants.front_left,
                TunerConstants.front_right,
                TunerConstants.back_left,
                TunerConstants.back_right,
            ],
        )

        # Create swerve requests for different drive modes
        self._field_centric_request = FieldCentric()
        self._brake_request = SwerveDriveBrake()
        self._idle_request = Idle()

        # Configure field-centric request defaults
        self._field_centric_request = self._field_centric_request.with_deadband(0.05).with_rotational_deadband(0.05)

        # Pending request to apply in execute()
        self._pending_request: Optional[SwerveRequest] = None

        # Field widget for simulation/dashboard
        self._field = Field2d()
        SmartDashboard.putData("Field", self._field)

        # Track if we're running in simulation
        self._is_simulation = RobotBase.isSimulation()

        # PID controllers for trajectory following
        self._x_controller = PIDController(self.TRAJECTORY_X_KP, 0.0, 0.0)
        self._y_controller = PIDController(self.TRAJECTORY_Y_KP, 0.0, 0.0)
        self._heading_controller = PIDController(self.TRAJECTORY_HEADING_KP, 0.0, 0.0)
        self._heading_controller.enableContinuousInput(-math.pi, math.pi)  # Wrap around at ±π

    def setup(self) -> None:
        """Called by MagicBot after injection. Perform any additional setup here."""
        pass

    def drive_field_centric(
        self,
        velocity_x: meters_per_second,
        velocity_y: meters_per_second,
        rotation_rate: radians_per_second,
    ) -> None:
        """Drive the robot using field-centric control.

        Args:
            velocity_x: Forward velocity in m/s (positive = forward on field).
            velocity_y: Left velocity in m/s (positive = left on field).
            rotation_rate: Counter-clockwise rotation rate in rad/s.
        """
        self._pending_request = (
            self._field_centric_request.with_velocity_x(velocity_x)
            .with_velocity_y(velocity_y)
            .with_rotational_rate(rotation_rate)
        )

    def drive(
        self,
        forward_speed: meters_per_second = 0,
        left_speed: meters_per_second = 0,
        ccw_speed: radians_per_second = 0,
    ) -> None:
        """Drive using field-centric control (legacy API for compatibility).

        Args:
            forward_speed: Forward velocity in m/s.
            left_speed: Left velocity in m/s.
            ccw_speed: Counter-clockwise rotation rate in rad/s.
        """
        self.drive_field_centric(forward_speed, left_speed, ccw_speed)

    def brake(self) -> None:
        """Set wheels to X-pattern brake configuration."""
        self._pending_request = self._brake_request

    def stop(self) -> None:
        """Stop all motors (coast)."""
        self._pending_request = self._idle_request

    def follow_trajectory(self, sample: SwerveSample) -> None:
        """Follow a Choreo trajectory sample.

        This method takes a trajectory sample and generates the appropriate
        chassis speeds to follow it, including feedforward velocities from
        the trajectory and feedback corrections based on position error.

        Use this with Choreo trajectories for autonomous path following.

        Args:
            sample: A SwerveSample from a Choreo trajectory containing
                    the desired pose and velocities at this point in time.
        """
        # Get the current pose of the robot
        pose = self.get_pose()

        # Calculate feedback corrections to push robot back toward trajectory
        # The sample contains the target position and the feedforward velocities
        x_feedback = self._x_controller.calculate(pose.X(), sample.x)
        y_feedback = self._y_controller.calculate(pose.Y(), sample.y)
        heading_feedback = self._heading_controller.calculate(pose.rotation().radians(), sample.heading)

        # Combine feedforward (from trajectory) with feedback (from PID)
        speeds = ChassisSpeeds(
            sample.vx + x_feedback,  # Forward velocity + X correction
            sample.vy + y_feedback,  # Sideways velocity + Y correction
            sample.omega + heading_feedback,  # Angular velocity + heading correction
        )

        # Apply the speeds using field-relative control
        self.drive_field_centric(speeds.vx, speeds.vy, speeds.omega)

    def reset_pose(self, pose: Pose2d) -> None:
        """Reset the robot's estimated pose.

        Args:
            pose: The new pose to set.
        """
        self._drivetrain.reset_pose(pose)

    def reset_heading(self) -> None:
        """Reset the robot's heading to 0 (forward)."""
        current_pose = self.get_pose()
        self._drivetrain.reset_pose(Pose2d(current_pose.translation(), Rotation2d(0)))

    def get_pose(self) -> Pose2d:
        """Get the robot's current estimated pose."""
        return self._drivetrain.get_state().pose

    def get_heading(self) -> Rotation2d:
        """Get the robot's current heading."""
        return self.get_pose().rotation()

    @feedback
    def heading_degrees(self) -> float:
        """Report heading in degrees to the dashboard."""
        return self.get_heading().degrees()

    @feedback
    def pose_x(self) -> float:
        """Report X position to the dashboard."""
        return self.get_pose().X()

    @feedback
    def pose_y(self) -> float:
        """Report Y position to the dashboard."""
        return self.get_pose().Y()

    def execute(self) -> None:
        """Called by MagicBot every loop iteration.

        Applies any pending swerve request and updates telemetry.
        """
        # Update simulation state if running in simulation
        if self._is_simulation:
            self._drivetrain.update_sim_state(SIM_LOOP_PERIOD, RobotController.getBatteryVoltage())

        # Apply pending request or idle if none
        if self._pending_request is not None:
            self._drivetrain.set_control(self._pending_request)
            self._pending_request = None
        else:
            # Default to idle if no request was made this cycle
            self._drivetrain.set_control(self._idle_request)

        # Update field visualization
        self._field.setRobotPose(self.get_pose())
